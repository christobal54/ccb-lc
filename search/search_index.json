{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The Earth Library \u00b6 A global reference library for land cover spectra, and tools for working with it. Documentation : earth-chris.github.io/earthlib Source code : earth-chris/earthlib Introduction \u00b6 earthlib is a spectral library and a set of software tools for satellite-base land cover mapping. The library contains several thousand unique spectral endmembers representing green vegetation, soil, non-photosynthetic vegetation, urban materials, and burned materials. The reflectance data cover the visible to the shortwave infrared wavelengths (400-2450 nm) at 10 nm band widths. The software tools (1) resample these data to match the wavelenths of popular satellite and airborne earth observing sensors and (2) run spectral mixture analysis in Google Earth Engine via the earthengine python package. The goal is to quantify spatial and temporal patterns of change in global vegetation cover, as well as patterns of soil cover, burned area, non-photosynthetic vegetation, and impervious surfaces. With earthlib , you can do this using most public satellite data sources . Installation \u00b6 This library can be installed via pip . pip install earthlib You can also clone the source repository and install it locally. git clone https://github.com/earth-chris/earthlib.git cd earthlib pip install -e . conda \u00b6 I recommend working with earthlib in conda (download from here ). The environment.yml file in this repository contains a series of packages that are either required ( earthengine-api ) or just convenient ( jupyter , folium ) to have. git clone https://github.com/earth-chris/earthlib.git cd earthlib conda env update Once the environment has been created, you can activate it with conda activate earthlib . Contact \u00b6 This work is supported by the Stanford Center for Conservation Biology and the Natural Capital Project.","title":"Home"},{"location":"#the-earth-library","text":"A global reference library for land cover spectra, and tools for working with it. Documentation : earth-chris.github.io/earthlib Source code : earth-chris/earthlib","title":"The Earth Library"},{"location":"#introduction","text":"earthlib is a spectral library and a set of software tools for satellite-base land cover mapping. The library contains several thousand unique spectral endmembers representing green vegetation, soil, non-photosynthetic vegetation, urban materials, and burned materials. The reflectance data cover the visible to the shortwave infrared wavelengths (400-2450 nm) at 10 nm band widths. The software tools (1) resample these data to match the wavelenths of popular satellite and airborne earth observing sensors and (2) run spectral mixture analysis in Google Earth Engine via the earthengine python package. The goal is to quantify spatial and temporal patterns of change in global vegetation cover, as well as patterns of soil cover, burned area, non-photosynthetic vegetation, and impervious surfaces. With earthlib , you can do this using most public satellite data sources .","title":"Introduction"},{"location":"#installation","text":"This library can be installed via pip . pip install earthlib You can also clone the source repository and install it locally. git clone https://github.com/earth-chris/earthlib.git cd earthlib pip install -e .","title":"Installation"},{"location":"#conda","text":"I recommend working with earthlib in conda (download from here ). The environment.yml file in this repository contains a series of packages that are either required ( earthengine-api ) or just convenient ( jupyter , folium ) to have. git clone https://github.com/earth-chris/earthlib.git cd earthlib conda env update Once the environment has been created, you can activate it with conda activate earthlib .","title":"conda"},{"location":"#contact","text":"This work is supported by the Stanford Center for Conservation Biology and the Natural Capital Project.","title":"Contact"},{"location":"introduction/","text":"Spectral Mixture Analysis \u00b6 The contents of a satellite image pixel are rarely homogeneous. An area 30x30m in size can include buildings, trees, and roads in urban environments; grasses, soils, and char in recently burned landscapes; trees, gaps, and downed logs in forested areas. These patterns all affect the reflectance patterns measured by satellites, and it's important to be able to estimate the sub-pixel abundances of each of these land cover types. Spectral mixture analysis is an approach to estimating the sub-pixel contents of an image pixel based on a set of representaive reflectance spectra (i.e., a reference library). Linear spectral mixture analysis uses an iterative, least-squares fitting approach to estimate the proportions of land cover types based on observed reflectance measurements. In order to run these analyses, you need 1) a high quality reference library of different land cover types, and 2) to resample these reference data to the wavelengths of the instrument you plan to analyze. To support these analysise, earthlib provides a rich spectral library with thousands of labeled reference spectra and tools for working with common satellite instruments.","title":"Introduction"},{"location":"introduction/#spectral-mixture-analysis","text":"The contents of a satellite image pixel are rarely homogeneous. An area 30x30m in size can include buildings, trees, and roads in urban environments; grasses, soils, and char in recently burned landscapes; trees, gaps, and downed logs in forested areas. These patterns all affect the reflectance patterns measured by satellites, and it's important to be able to estimate the sub-pixel abundances of each of these land cover types. Spectral mixture analysis is an approach to estimating the sub-pixel contents of an image pixel based on a set of representaive reflectance spectra (i.e., a reference library). Linear spectral mixture analysis uses an iterative, least-squares fitting approach to estimate the proportions of land cover types based on observed reflectance measurements. In order to run these analyses, you need 1) a high quality reference library of different land cover types, and 2) to resample these reference data to the wavelengths of the instrument you plan to analyze. To support these analysise, earthlib provides a rich spectral library with thousands of labeled reference spectra and tools for working with common satellite instruments.","title":"Spectral Mixture Analysis"},{"location":"sources/","text":"Data Sources \u00b6 The Earth Library is a collection of collections, merging spectral measurments and models from a range of data sources. earthlib provides routines for resampling this collection to match the wavelenghts of many common optical imaging sensors. Spectral libraries \u00b6 The following data sources were filtered and resampled prior to inclusion in earthlib . Vegetation spectra modeled using PROSAIL (using PyPROSAIL ) World Agroforestry (ICRAF) Global Soil Spectral Library The Joint Fire Science Program UCSB's Urban Reflectance Spectra UW/BNL/NASA HySPIRI airborne calibration spectra USGS Spectral Library Version 7 Below are plots for the primary land cover spectra included in earthlib . Supported sensors \u00b6 In the figure above, the black lines indicate the full-width of each band, and the colored squares mark the center wavelength for each band. NEON , an imaging spectrometer system, measures the full shortwave spectrum ( 400-2500 nm ) using over 400 spectral bands to measure continuous spectral variance (these bands have been resampled to match the range/centers of the earthlib reference library).","title":"Data Sources"},{"location":"sources/#data-sources","text":"The Earth Library is a collection of collections, merging spectral measurments and models from a range of data sources. earthlib provides routines for resampling this collection to match the wavelenghts of many common optical imaging sensors.","title":"Data Sources"},{"location":"sources/#spectral-libraries","text":"The following data sources were filtered and resampled prior to inclusion in earthlib . Vegetation spectra modeled using PROSAIL (using PyPROSAIL ) World Agroforestry (ICRAF) Global Soil Spectral Library The Joint Fire Science Program UCSB's Urban Reflectance Spectra UW/BNL/NASA HySPIRI airborne calibration spectra USGS Spectral Library Version 7 Below are plots for the primary land cover spectra included in earthlib .","title":"Spectral libraries"},{"location":"sources/#supported-sensors","text":"In the figure above, the black lines indicate the full-width of each band, and the colored squares mark the center wavelength for each band. NEON , an imaging spectrometer system, measures the full shortwave spectrum ( 400-2500 nm ) using over 400 spectral bands to measure continuous spectral variance (these bands have been resampled to match the range/centers of the earthlib reference library).","title":"Supported sensors"},{"location":"module/Map/","text":"Functions for interacting with earth engine map data in folium. addLayer ( self , eeImage , visParams = {}, name = 'Layer' ) \u00b6 Adds an earth engine image object to a folium map. This function is designed to be appended to a folium map object. source: colab.research.google.com/github/google/earthengine-api/blob/master/python/examples/ipynb/ee-api-colab-setup.ipynb Parameters: Name Type Description Default eeImage an ee image object. required visParams dictionary of ee visualization parameters. {} name the name to display in the map legend. 'Layer' Returns: Type Description None. Updates the map object this function is appended to. Source code in earthlib/Map.py def addLayer ( self , eeImage , visParams = {}, name = \"Layer\" ): \"\"\"Adds an earth engine image object to a folium map. This function is designed to be appended to a folium `map` object. source: https://colab.research.google.com/github/google/earthengine-api/blob/master/python/examples/ipynb/ee-api-colab-setup.ipynb Args: eeImage: an ee image object. visParams: dictionary of ee visualization parameters. name: the name to display in the map legend. Returns: None. Updates the `map` object this function is appended to. \"\"\" map_id_dict = _ee . Image ( eeImage ) . getMapId ( visParams ) _folium . raster_layers . TileLayer ( tiles = map_id_dict [ \"tile_fetcher\" ] . url_format , attr = \"Map Data &copy; <a href='https://earthengine.google.com/'>Google Earth Engine</a>\" , name = name , overlay = True , control = True , ) . add_to ( self )","title":"earthlib.Map"},{"location":"module/Map/#earthlib.Map.addLayer","text":"Adds an earth engine image object to a folium map. This function is designed to be appended to a folium map object. source: colab.research.google.com/github/google/earthengine-api/blob/master/python/examples/ipynb/ee-api-colab-setup.ipynb Parameters: Name Type Description Default eeImage an ee image object. required visParams dictionary of ee visualization parameters. {} name the name to display in the map legend. 'Layer' Returns: Type Description None. Updates the map object this function is appended to. Source code in earthlib/Map.py def addLayer ( self , eeImage , visParams = {}, name = \"Layer\" ): \"\"\"Adds an earth engine image object to a folium map. This function is designed to be appended to a folium `map` object. source: https://colab.research.google.com/github/google/earthengine-api/blob/master/python/examples/ipynb/ee-api-colab-setup.ipynb Args: eeImage: an ee image object. visParams: dictionary of ee visualization parameters. name: the name to display in the map legend. Returns: None. Updates the `map` object this function is appended to. \"\"\" map_id_dict = _ee . Image ( eeImage ) . getMapId ( visParams ) _folium . raster_layers . TileLayer ( tiles = map_id_dict [ \"tile_fetcher\" ] . url_format , attr = \"Map Data &copy; <a href='https://earthengine.google.com/'>Google Earth Engine</a>\" , name = name , overlay = True , control = True , ) . add_to ( self )","title":"addLayer()"},{"location":"module/Mask/","text":"Functions for masking earth engine images. bySensor ( sensor ) \u00b6 Returns the appropriate mask function to use by sensor type. Parameters: Name Type Description Default sensor string with the sensor name to return (e.g. \"Landsat8\", \"Sentinel2\"). required Returns: Type Description function the mask function associated with a sensor to pass to an ee .map() call Source code in earthlib/Mask.py def bySensor ( sensor ): \"\"\"Returns the appropriate mask function to use by sensor type. Args: sensor: string with the sensor name to return (e.g. \"Landsat8\", \"Sentinel2\"). Returns: function: the mask function associated with a sensor to pass to an ee .map() call \"\"\" lookup = { \"Landsat8\" : Landsat8 , \"Sentinel2\" : Sentinel2 , \"MODIS\" : MODIS , } function = lookup [ sensor ] return function Landsat8 ( img ) \u00b6 Masks Landsat8 images. Parameters: Name Type Description Default img the ee.Image to mask. Must have a Landsat \"pixel_qa\" band. required Returns: Type Description img the same input image with an updated mask. Source code in earthlib/Mask.py def Landsat8 ( img ): \"\"\"Masks Landsat8 images. Args: img: the ee.Image to mask. Must have a Landsat \"pixel_qa\" band. Returns: img: the same input image with an updated mask. \"\"\" cloudShadowBitMask = _ee . Number ( 2 ) . pow ( 3 ) . int () cloudsBitMask = _ee . Number ( 2 ) . pow ( 5 ) . int () qa = img . select ( \"pixel_qa\" ) mask = ( qa . bitwiseAnd ( cloudShadowBitMask ) . eq ( 0 ) . And ( qa . bitwiseAnd ( cloudsBitMask ) . eq ( 0 )) ) return img . mask ( mask ) MODIS ( img ) \u00b6 Masks MODIS images. Parameters: Name Type Description Default img the ee.Image to mask. Must have a MODIS \"state_1km\" band. required Returns: Type Description img the same input image with an updated mask. Source code in earthlib/Mask.py def MODIS ( img ): \"\"\"Masks MODIS images. Args: img: the ee.Image to mask. Must have a MODIS \"state_1km\" band. Returns: img: the same input image with an updated mask. \"\"\" cloudShadowBitMask = _ee . Number ( 2 ) . pow ( 2 ) . int () cloudsBitMask = _ee . Number ( 2 ) . pow ( 0 ) . int () qa = img . select ( \"state_1km\" ) mask = ( qa . bitwiseAnd ( cloudShadowBitMask ) . eq ( 0 ) . And ( qa . bitwiseAnd ( cloudsBitMask ) . eq ( 0 )) ) return img . mask ( mask ) Sentinel2 ( img ) \u00b6 Masks Sentinel2 images. Parameters: Name Type Description Default img the ee.Image to mask. Must have a Sentinel \"QA60\" band. required Returns: Type Description img the same input image with an updated mask. Source code in earthlib/Mask.py def Sentinel2 ( img ): \"\"\"Masks Sentinel2 images. Args: img: the ee.Image to mask. Must have a Sentinel \"QA60\" band. Returns: img: the same input image with an updated mask. \"\"\" cirrusBitMask = _ee . Number ( 2 ) . pow ( 11 ) . int () cloudsBitMask = _ee . Number ( 2 ) . pow ( 10 ) . int () qa = img . select ( \"QA60\" ) mask = qa . bitwiseAnd ( cloudsBitMask ) . eq ( 0 ) . And ( qa . bitwiseAnd ( cirrusBitMask ) . eq ( 0 )) return img . updateMask ( mask )","title":"earthlib.Mask"},{"location":"module/Mask/#earthlib.Mask.bySensor","text":"Returns the appropriate mask function to use by sensor type. Parameters: Name Type Description Default sensor string with the sensor name to return (e.g. \"Landsat8\", \"Sentinel2\"). required Returns: Type Description function the mask function associated with a sensor to pass to an ee .map() call Source code in earthlib/Mask.py def bySensor ( sensor ): \"\"\"Returns the appropriate mask function to use by sensor type. Args: sensor: string with the sensor name to return (e.g. \"Landsat8\", \"Sentinel2\"). Returns: function: the mask function associated with a sensor to pass to an ee .map() call \"\"\" lookup = { \"Landsat8\" : Landsat8 , \"Sentinel2\" : Sentinel2 , \"MODIS\" : MODIS , } function = lookup [ sensor ] return function","title":"bySensor()"},{"location":"module/Mask/#earthlib.Mask.Landsat8","text":"Masks Landsat8 images. Parameters: Name Type Description Default img the ee.Image to mask. Must have a Landsat \"pixel_qa\" band. required Returns: Type Description img the same input image with an updated mask. Source code in earthlib/Mask.py def Landsat8 ( img ): \"\"\"Masks Landsat8 images. Args: img: the ee.Image to mask. Must have a Landsat \"pixel_qa\" band. Returns: img: the same input image with an updated mask. \"\"\" cloudShadowBitMask = _ee . Number ( 2 ) . pow ( 3 ) . int () cloudsBitMask = _ee . Number ( 2 ) . pow ( 5 ) . int () qa = img . select ( \"pixel_qa\" ) mask = ( qa . bitwiseAnd ( cloudShadowBitMask ) . eq ( 0 ) . And ( qa . bitwiseAnd ( cloudsBitMask ) . eq ( 0 )) ) return img . mask ( mask )","title":"Landsat8()"},{"location":"module/Mask/#earthlib.Mask.MODIS","text":"Masks MODIS images. Parameters: Name Type Description Default img the ee.Image to mask. Must have a MODIS \"state_1km\" band. required Returns: Type Description img the same input image with an updated mask. Source code in earthlib/Mask.py def MODIS ( img ): \"\"\"Masks MODIS images. Args: img: the ee.Image to mask. Must have a MODIS \"state_1km\" band. Returns: img: the same input image with an updated mask. \"\"\" cloudShadowBitMask = _ee . Number ( 2 ) . pow ( 2 ) . int () cloudsBitMask = _ee . Number ( 2 ) . pow ( 0 ) . int () qa = img . select ( \"state_1km\" ) mask = ( qa . bitwiseAnd ( cloudShadowBitMask ) . eq ( 0 ) . And ( qa . bitwiseAnd ( cloudsBitMask ) . eq ( 0 )) ) return img . mask ( mask )","title":"MODIS()"},{"location":"module/Mask/#earthlib.Mask.Sentinel2","text":"Masks Sentinel2 images. Parameters: Name Type Description Default img the ee.Image to mask. Must have a Sentinel \"QA60\" band. required Returns: Type Description img the same input image with an updated mask. Source code in earthlib/Mask.py def Sentinel2 ( img ): \"\"\"Masks Sentinel2 images. Args: img: the ee.Image to mask. Must have a Sentinel \"QA60\" band. Returns: img: the same input image with an updated mask. \"\"\" cirrusBitMask = _ee . Number ( 2 ) . pow ( 11 ) . int () cloudsBitMask = _ee . Number ( 2 ) . pow ( 10 ) . int () qa = img . select ( \"QA60\" ) mask = qa . bitwiseAnd ( cloudsBitMask ) . eq ( 0 ) . And ( qa . bitwiseAnd ( cirrusBitMask ) . eq ( 0 )) return img . updateMask ( mask )","title":"Sentinel2()"},{"location":"module/Read/","text":"Functions for reading specifically formatted data. endmembers () \u00b6 Reads the earthlib spectral endmember library. Returns: Type Description s an earthlib spectralObject with the endmember library reflectance data. Source code in earthlib/Read.py def endmembers (): \"\"\"Reads the earthlib spectral endmember library. Args: None. Returns: s: an earthlib spectralObject with the endmember library reflectance data. \"\"\" s = spectralLibrary ( _endmember_path ) return s jfsp ( path ) \u00b6 Reads JFSP-formatted ASCII files. Reads the ASCII format spectral data from the joint-fire-science-program and returns an object with the mean and \u00b1 standard deviation reflectance data. Reference: www.frames.gov/assessing-burn-severity/spectral-library/overview Parameters: Name Type Description Default path file path to the JFSP spectra text file. required Returns: Type Description s an earthlib spectralObject with the JFSP reflectance data. Source code in earthlib/Read.py def jfsp ( path ): \"\"\"Reads JFSP-formatted ASCII files. Reads the ASCII format spectral data from the joint-fire-science-program and returns an object with the mean and +/- standard deviation reflectance data. Reference: https://www.frames.gov/assessing-burn-severity/spectral-library/overview Args: path: file path to the JFSP spectra text file. Returns: s: an earthlib spectralObject with the JFSP reflectance data. \"\"\" # create the spectral object s = spectralObject ( 1 , type = \"asd\" ) s . spectra_stdevm = _np . zeros ( s . spectra . shape ) s . spectra_stdevp = _np . zeros ( s . spectra . shape ) # open the file and read the data with open ( path , \"r\" ) as f : f . readline () for i , line in enumerate ( f ): line = line . strip () . split () s . spectra [ 0 , i ] = line [ 1 ] s . spectra_stdevp [ 0 , i ] = line [ 2 ] s . spectra_stdevm [ 0 , i ] = line [ 3 ] return s spectralLibrary ( path ) \u00b6 Reads an ENVI-format spectral library into memory. Parameters: Name Type Description Default path file path to the ENVI spectral library file. Looks for a .hdr sidecar file. required Returns: Type Description s an earthlib spectralObject with the spectral library data. Source code in earthlib/Read.py def spectralLibrary ( path ): \"\"\"Reads an ENVI-format spectral library into memory. Args: path: file path to the ENVI spectral library file. Looks for a .hdr sidecar file. Returns: s: an earthlib spectralObject with the spectral library data. \"\"\" # check for header files if _checkFile ( path [: - 4 ] + \".hdr\" ): hdr = path [: - 4 ] + \".hdr\" else : if _checkFile ( path + \".hdr\" ): hdr = path + \".hdr\" else : return None # read the spectral data slib = _spectral . envi . open ( hdr , path ) s = _spectralObject ( slib . params . nrows , slib . params . ncols , band_centers = _np . asarray ( slib . bands . centers ), band_unit = slib . bands . band_unit , band_quantity = slib . bands . band_quantity , ) # pull the spectra and names from the library s . spectra = slib . spectra s . names = slib . names return s usgs ( path ) \u00b6 Reads USGS-formatted ASCII files. Reads the ascii format spectral data from USGS and returns an object with the mean and \u00b1 standard deviation. Reference: www.sciencebase.gov/catalog/item/5807a2a2e4b0841e59e3a18d Parameters: Name Type Description Default path file path the the USGS spectra text file. required Returns: Type Description s an earthlib spectralObject with the USGS reflectance data. Source code in earthlib/Read.py def usgs ( path ): \"\"\"Reads USGS-formatted ASCII files. Reads the ascii format spectral data from USGS and returns an object with the mean and +/- standard deviation. Reference: https://www.sciencebase.gov/catalog/item/5807a2a2e4b0841e59e3a18d Args: path: file path the the USGS spectra text file. Returns: s: an earthlib spectralObject with the USGS reflectance data. \"\"\" # open the file and read header info with open ( path , \"r\" ) as f : x_start = \"gibberish\" for line in f : if x_start in line : break if \"Name:\" in line : spectrum_name = line . strip () . split ( \"Name:\" )[ - 1 ] . strip () if \"X Units:\" in line : band_unit = line . strip () . split () band_unit = band_unit [ - 1 ] . strip ( \"()\" ) . capitalize () if \"Y Units:\" in line : refl_unit = line . strip () . split () refl_unit = refl_unit [ - 1 ] . strip ( \"()\" ) . capitalize () if \"First X Value:\" in line : x_start = line . strip () . split ()[ - 1 ] if \"Number of X Values:\" in line : n_values = int ( line . strip () . split ()[ - 1 ]) # now that we got our header info, create the arrays band_centers = _np . empty ( n_values ) reflectance = _np . empty ( n_values ) line = line . strip () . split () band_centers [ 0 ] = float ( line [ 0 ]) reflectance [ 0 ] = float ( line [ 1 ]) # resume reading through file i = 1 for line in f : line = line . strip () . split () band_centers [ i ] = float ( line [ 0 ]) reflectance [ i ] = float ( line [ 1 ]) i += 1 # some files read last -> first wavelength if band_centers [ 0 ] > band_centers [ - 1 ]: band_centers = band_centers [:: - 1 ] reflectance = reflectance [:: 1 ] # convert units to nanometers and scale 0-1 if band_unit . lower () == \"micrometers\" : band_centers *= 1000.0 band_unit = \"Nanometers\" if refl_unit . lower () == \"percent\" : reflectance /= 100.0 # create the spectral object s = spectralObject ( 1 , n_values , band_centers = band_centers , band_unit = band_unit , band_quantity = \"Wavelength\" , ) # assign relevant values s . spectra [ 0 ] = reflectance if spectrum_name : s . names [ 0 ] = spectrum_name return s","title":"earthlib.Read"},{"location":"module/Read/#earthlib.Read.endmembers","text":"Reads the earthlib spectral endmember library. Returns: Type Description s an earthlib spectralObject with the endmember library reflectance data. Source code in earthlib/Read.py def endmembers (): \"\"\"Reads the earthlib spectral endmember library. Args: None. Returns: s: an earthlib spectralObject with the endmember library reflectance data. \"\"\" s = spectralLibrary ( _endmember_path ) return s","title":"endmembers()"},{"location":"module/Read/#earthlib.Read.jfsp","text":"Reads JFSP-formatted ASCII files. Reads the ASCII format spectral data from the joint-fire-science-program and returns an object with the mean and \u00b1 standard deviation reflectance data. Reference: www.frames.gov/assessing-burn-severity/spectral-library/overview Parameters: Name Type Description Default path file path to the JFSP spectra text file. required Returns: Type Description s an earthlib spectralObject with the JFSP reflectance data. Source code in earthlib/Read.py def jfsp ( path ): \"\"\"Reads JFSP-formatted ASCII files. Reads the ASCII format spectral data from the joint-fire-science-program and returns an object with the mean and +/- standard deviation reflectance data. Reference: https://www.frames.gov/assessing-burn-severity/spectral-library/overview Args: path: file path to the JFSP spectra text file. Returns: s: an earthlib spectralObject with the JFSP reflectance data. \"\"\" # create the spectral object s = spectralObject ( 1 , type = \"asd\" ) s . spectra_stdevm = _np . zeros ( s . spectra . shape ) s . spectra_stdevp = _np . zeros ( s . spectra . shape ) # open the file and read the data with open ( path , \"r\" ) as f : f . readline () for i , line in enumerate ( f ): line = line . strip () . split () s . spectra [ 0 , i ] = line [ 1 ] s . spectra_stdevp [ 0 , i ] = line [ 2 ] s . spectra_stdevm [ 0 , i ] = line [ 3 ] return s","title":"jfsp()"},{"location":"module/Read/#earthlib.Read.spectralLibrary","text":"Reads an ENVI-format spectral library into memory. Parameters: Name Type Description Default path file path to the ENVI spectral library file. Looks for a .hdr sidecar file. required Returns: Type Description s an earthlib spectralObject with the spectral library data. Source code in earthlib/Read.py def spectralLibrary ( path ): \"\"\"Reads an ENVI-format spectral library into memory. Args: path: file path to the ENVI spectral library file. Looks for a .hdr sidecar file. Returns: s: an earthlib spectralObject with the spectral library data. \"\"\" # check for header files if _checkFile ( path [: - 4 ] + \".hdr\" ): hdr = path [: - 4 ] + \".hdr\" else : if _checkFile ( path + \".hdr\" ): hdr = path + \".hdr\" else : return None # read the spectral data slib = _spectral . envi . open ( hdr , path ) s = _spectralObject ( slib . params . nrows , slib . params . ncols , band_centers = _np . asarray ( slib . bands . centers ), band_unit = slib . bands . band_unit , band_quantity = slib . bands . band_quantity , ) # pull the spectra and names from the library s . spectra = slib . spectra s . names = slib . names return s","title":"spectralLibrary()"},{"location":"module/Read/#earthlib.Read.usgs","text":"Reads USGS-formatted ASCII files. Reads the ascii format spectral data from USGS and returns an object with the mean and \u00b1 standard deviation. Reference: www.sciencebase.gov/catalog/item/5807a2a2e4b0841e59e3a18d Parameters: Name Type Description Default path file path the the USGS spectra text file. required Returns: Type Description s an earthlib spectralObject with the USGS reflectance data. Source code in earthlib/Read.py def usgs ( path ): \"\"\"Reads USGS-formatted ASCII files. Reads the ascii format spectral data from USGS and returns an object with the mean and +/- standard deviation. Reference: https://www.sciencebase.gov/catalog/item/5807a2a2e4b0841e59e3a18d Args: path: file path the the USGS spectra text file. Returns: s: an earthlib spectralObject with the USGS reflectance data. \"\"\" # open the file and read header info with open ( path , \"r\" ) as f : x_start = \"gibberish\" for line in f : if x_start in line : break if \"Name:\" in line : spectrum_name = line . strip () . split ( \"Name:\" )[ - 1 ] . strip () if \"X Units:\" in line : band_unit = line . strip () . split () band_unit = band_unit [ - 1 ] . strip ( \"()\" ) . capitalize () if \"Y Units:\" in line : refl_unit = line . strip () . split () refl_unit = refl_unit [ - 1 ] . strip ( \"()\" ) . capitalize () if \"First X Value:\" in line : x_start = line . strip () . split ()[ - 1 ] if \"Number of X Values:\" in line : n_values = int ( line . strip () . split ()[ - 1 ]) # now that we got our header info, create the arrays band_centers = _np . empty ( n_values ) reflectance = _np . empty ( n_values ) line = line . strip () . split () band_centers [ 0 ] = float ( line [ 0 ]) reflectance [ 0 ] = float ( line [ 1 ]) # resume reading through file i = 1 for line in f : line = line . strip () . split () band_centers [ i ] = float ( line [ 0 ]) reflectance [ i ] = float ( line [ 1 ]) i += 1 # some files read last -> first wavelength if band_centers [ 0 ] > band_centers [ - 1 ]: band_centers = band_centers [:: - 1 ] reflectance = reflectance [:: 1 ] # convert units to nanometers and scale 0-1 if band_unit . lower () == \"micrometers\" : band_centers *= 1000.0 band_unit = \"Nanometers\" if refl_unit . lower () == \"percent\" : reflectance /= 100.0 # create the spectral object s = spectralObject ( 1 , n_values , band_centers = band_centers , band_unit = band_unit , band_quantity = \"Wavelength\" , ) # assign relevant values s . spectra [ 0 ] = reflectance if spectrum_name : s . names [ 0 ] = spectrum_name return s","title":"usgs()"},{"location":"module/Unmix/","text":"Routines for performing spectral unmixing on earth engine images. BVN ( img , ** normalization ) \u00b6 Unmixes using Burned-Vegetation-NonphotosyntheticVegetation (BVN) endmembers. Parameters: Name Type Description Default img the ee.Image to unmix. required **normalization: keyword arguments to pass to fractionalCover(), like shade_normalize=True. Returns: Type Description unmixed a 4-band image file in order of (burned-veg-npv-soil). Source code in earthlib/Unmix.py def BVN ( img , ** normalization ): \"\"\"Unmixes using Burned-Vegetation-NonphotosyntheticVegetation (BVN) endmembers. Args: img: the ee.Image to unmix. **normalization: keyword arguments to pass to fractionalCover(), like shade_normalize=True. Returns: unmixed: a 4-band image file in order of (burned-veg-npv-soil). \"\"\" endmembers = [ burn , pv , npv ] endmember_names = [ \"burned\" , \"pv\" , \"npv\" ] unmixed = fractionalCover ( img , endmembers , endmember_names , ** normalization ) return unmixed computeModeledSpectra ( endmembers , fractions ) \u00b6 Constructs a modeled spectrum for each pixel based on endmember fractions. Parameters: Name Type Description Default endmembers a list of _ee.List() items, each representing an endmember spectrum. required fractions ee.Image output from .unmix() with the same number of bands as items in endmembers . required Returns: Type Description modeled_reflectance an _ee.Image with n_bands equal to the number of endmember bands. Source code in earthlib/Unmix.py def computeModeledSpectra ( endmembers , fractions ): \"\"\"Constructs a modeled spectrum for each pixel based on endmember fractions. Args: endmembers: a list of _ee.List() items, each representing an endmember spectrum. fractions: ee.Image output from .unmix() with the same number of bands as items in `endmembers`. Returns: modeled_reflectance: an _ee.Image with n_bands equal to the number of endmember bands. \"\"\" # compute the number of endmember bands nb = int ( endmembers [ 0 ] . length () . getInfo ()) band_range = list ( range ( nb )) band_names = [ f \"M { band : 02d } \" for band in band_range ] # create a list to store each reflectance fraction refl_fraction_images = list () # loop through each endmember and mulitply the fraction estimated by the reflectance value for i , endmember in enumerate ( endmembers ): fraction = fractions . select ([ i ]) refl_fraction_list = [ fraction . multiply ( _ee . Image ( endmember . get ( band ) . getInfo ())) for band in band_range ] refl_fraction_images . append ( _ee . ImageCollection . fromImages ( refl_fraction_list ) . toBands () . select ( band_range , band_names ) ) # convert these images to an image collection and sum them together to reconstruct the spectrum modeled_reflectance = ( _ee . ImageCollection . fromImages ( refl_fraction_images ) . sum () . toFloat () . select ( band_range , band_names ) ) return modeled_reflectance computeSpectralRMSE ( measured , modeled ) \u00b6 Computes root mean squared error between measured and modeled spectra. Parameters: Name Type Description Default measured an ee.Image of measured reflectance. required modeled an ee.Image of modeled reflectance. required Returns: Type Description rmse a floating point _ee.Image with pixel-wise RMSE values. Source code in earthlib/Unmix.py def computeSpectralRMSE ( measured , modeled ): \"\"\"Computes root mean squared error between measured and modeled spectra. Args: measured: an ee.Image of measured reflectance. modeled: an ee.Image of modeled reflectance. Returns: rmse: a floating point _ee.Image with pixel-wise RMSE values. \"\"\" # harmonize band info to ensure element-wise computation band_names = list ( measured . bandNames () . getInfo ()) band_range = list ( range ( len ( band_names ))) # compute rmse rmse = ( measured . select ( band_range , band_names ) . subtract ( modeled . select ( band_range , band_names )) . pow ( 2 ) . reduce ( _ee . Reducer . sum ()) . sqrt () . select ([ 0 ], [ \"RMSE\" ]) . toFloat () ) return rmse computeWeight ( fractions , rmse_sum ) \u00b6 Computes the relative weight for an image's RMSE based on the sum of the global RMSE. Parameters: Name Type Description Default fractions a multi-band ee.Image object with an 'RMSE' band. required rmse_sum a single-band ee.Image object with the global RMSE value. required Returns: Type Description unweighted appends the fractions Image with a 'weight' band. Source code in earthlib/Unmix.py def computeWeight ( fractions , rmse_sum ): \"\"\"Computes the relative weight for an image's RMSE based on the sum of the global RMSE. Args: fractions: a multi-band ee.Image object with an 'RMSE' band. rmse_sum: a single-band ee.Image object with the global RMSE value. Returns: unweighted: appends the fractions Image with a 'weight' band. \"\"\" rmse = fractions . select ([ \"RMSE\" ]) ratio = rmse . divide ( rmse_sum ) . toFloat () . select ([ 0 ], [ \"ratio\" ]) weight = _ee . Image ( 1 ) . subtract ( ratio ) . select ([ 0 ], [ \"weight\" ]) unweighted = fractions . addBands ([ weight , ratio ]) return unweighted fractionalCover ( img , endmembers , endmember_names , shade_normalize = False ) \u00b6 Computes the percent cover of each endmember spectra. Parameters: Name Type Description Default img the ee.Image to unmix. required endmembers lists of ee.List objects, each element corresponding to a sub. required endmember_names list of names for each endmember. must match the number of lists passed. required shade_normalize flag to apply shade normalization during unmixing. False Returns: Type Description unmixed a 3-band image file in order of (soil-veg-impervious). Source code in earthlib/Unmix.py def fractionalCover ( img , endmembers , endmember_names , shade_normalize = False , ): \"\"\"Computes the percent cover of each endmember spectra. Args: img: the ee.Image to unmix. endmembers: lists of ee.List objects, each element corresponding to a sub. endmember_names: list of names for each endmember. must match the number of lists passed. shade_normalize: flag to apply shade normalization during unmixing. Returns: unmixed: a 3-band image file in order of (soil-veg-impervious). \"\"\" n_bands = len ( list ( img . bandNames () . getInfo ())) n_classes = len ( endmembers ) n_endmembers = len ( endmembers [ 0 ]) band_numbers = list ( range ( n_classes )) shade = _ee . List ([ 0 ] * n_bands ) # create a list of images to append and later convert to an image collection unmixed = list () # loop through each iteration and unmix each for spectra in _tqdm ( list ( zip ( * endmembers )), total = n_endmembers , desc = \"Unmixing\" ): if shade_normalize : spectra += ( shade ,) unmixed_iter = img . unmix ( spectra , True , True ) . toFloat () # run the forward model to evaluate the fractional cover fit modeled_reflectance = computeModeledSpectra ( spectra , unmixed_iter ) rmse = computeSpectralRMSE ( img , modeled_reflectance ) # normalize by the observed shade fraction if shade_normalize : shade_fraction = unmixed_iter . select ([ n_classes ]) . subtract ( 1 ) . abs () unmixed_iter = unmixed_iter . divide ( shade_fraction ) # rename the bands and append an rmse band unmixed . append ( unmixed_iter . select ( band_numbers , endmember_names ) . addBands ( rmse ) ) # use the sum of rmse to weight each estimate rmse_sum = _ee . Image ( _ee . ImageCollection . fromImages ( unmixed ) . select ([ \"RMSE\" ]) . sum () . select ([ 0 ], [ \"SUM\" ]) . toFloat () ) unscaled = [ computeWeight ( fractions , rmse_sum ) for fractions in unmixed ] # use these weights to scale each unmixing estimate weight_sum = _ee . Image ( _ee . ImageCollection . fromImages ( unscaled ) . select ([ \"weight\" ]) . sum () . toFloat () ) scaled = [ weightedAverage ( fractions , weight_sum ) for fractions in unscaled ] # reduce it to a single image and return unmixed = _ee . ImageCollection . fromImages ( scaled ) . sum () . toFloat () return unmixed Initialize ( sensor , n = 30 , bands = None ) \u00b6 Initializes sensor-specific global variables. Parameters: Name Type Description Default sensor the name of the sensor (from earthlib.listSensors()). required n the number of iterations for unmixing. 30 bands a list of bands to select (from earthlib.getBands(sensor)). None Returns: Type Description None creates a series of global endmember variables. Source code in earthlib/Unmix.py def Initialize ( sensor , n = 30 , bands = None ): \"\"\"Initializes sensor-specific global variables. Args: sensor: the name of the sensor (from earthlib.listSensors()). n: the number of iterations for unmixing. bands: a list of bands to select (from earthlib.getBands(sensor)). Returns: None: creates a series of global endmember variables. \"\"\" # get them as a python array pv_list = _selectSpectra ( \"vegetation\" , sensor , n , bands ) npv_list = _selectSpectra ( \"npv\" , sensor , n , bands ) soil_list = _selectSpectra ( \"bare\" , sensor , n , bands ) burn_list = _selectSpectra ( \"burn\" , sensor , n , bands ) urban_list = _selectSpectra ( \"urban\" , sensor , n , bands ) # create a series of global variables for later global pv global npv global soil global burn global urban # then convert them to ee lists pv = [ _ee . List ( pv_spectra . tolist ()) for pv_spectra in pv_list ] npv = [ _ee . List ( npv_spectra . tolist ()) for npv_spectra in npv_list ] soil = [ _ee . List ( soil_spectra . tolist ()) for soil_spectra in soil_list ] burn = [ _ee . List ( burn_spectra . tolist ()) for burn_spectra in burn_list ] urban = [ _ee . List ( urban_spectra . tolist ()) for urban_spectra in urban_list ] SVN ( img , ** normalization ) \u00b6 Unmixes using Soil-Vegetation-NonphotosyntheticVegetation (SVN) endmembers. Parameters: Name Type Description Default img the ee.Image to unmix. required **normalization keyword arguments to pass to fractionalCover(), like shade_normalize=True. {} Returns: Type Description unmixed a 3-band image file in order of (soil-veg-npv). Source code in earthlib/Unmix.py def SVN ( img , ** normalization ): \"\"\"Unmixes using Soil-Vegetation-NonphotosyntheticVegetation (SVN) endmembers. Args: img: the ee.Image to unmix. **normalization: keyword arguments to pass to fractionalCover(), like shade_normalize=True. Returns: unmixed: a 3-band image file in order of (soil-veg-npv). \"\"\" endmembers = [ soil , pv , npv ] endmember_names = [ \"soil\" , \"pv\" , \"npv\" ] unmixed = fractionalCover ( img , endmembers , endmember_names , ** normalization ) return unmixed VIS ( img , ** normalization ) \u00b6 Unmixes according to the Vegetation-Impervious-Soil (VIS) approach. Parameters: Name Type Description Default img the ee.Image to unmix. required **normalization keyword arguments to pass to fractionalCover(), like shade_normalize=True. {} Returns: Type Description unmixed a 3-band image file in order of (soil-veg-impervious). Source code in earthlib/Unmix.py def VIS ( img , ** normalization ): \"\"\"Unmixes according to the Vegetation-Impervious-Soil (VIS) approach. Args: img: the ee.Image to unmix. **normalization: keyword arguments to pass to fractionalCover(), like shade_normalize=True. Returns: unmixed: a 3-band image file in order of (soil-veg-impervious). \"\"\" endmembers = [ soil , pv , urban ] endmember_names = [ \"soil\" , \"pv\" , \"impervious\" ] unmixed = fractionalCover ( img , endmembers , endmember_names , ** normalization ) return unmixed weightedAverage ( fractions , weight_sum ) \u00b6 Computes an RMSE-weighted fractional cover image. Parameters: Name Type Description Default fractions a multi-band ee.Image object with a 'weight' band. required weight_sum a single-band _eeImage object with the global weight sum. required Returns: Type Description weighted scaled fractional cover Image. Source code in earthlib/Unmix.py def weightedAverage ( fractions , weight_sum ): \"\"\"Computes an RMSE-weighted fractional cover image. Args: fractions: a multi-band ee.Image object with a 'weight' band. weight_sum: a single-band _eeImage object with the global weight sum. Returns: weighted: scaled fractional cover Image. \"\"\" # harmonize band info band_names = list ( fractions . bandNames () . getInfo ()) band_names . pop ( band_names . index ( \"weight\" )) band_range = list ( range ( len ( band_names ))) scaler = fractions . select ([ \"weight\" ]) . divide ( weight_sum ) weighted = fractions . select ( band_range , band_names ) . multiply ( scaler ) return weighted","title":"earthlib.Unmix"},{"location":"module/Unmix/#earthlib.Unmix.BVN","text":"Unmixes using Burned-Vegetation-NonphotosyntheticVegetation (BVN) endmembers. Parameters: Name Type Description Default img the ee.Image to unmix. required **normalization: keyword arguments to pass to fractionalCover(), like shade_normalize=True. Returns: Type Description unmixed a 4-band image file in order of (burned-veg-npv-soil). Source code in earthlib/Unmix.py def BVN ( img , ** normalization ): \"\"\"Unmixes using Burned-Vegetation-NonphotosyntheticVegetation (BVN) endmembers. Args: img: the ee.Image to unmix. **normalization: keyword arguments to pass to fractionalCover(), like shade_normalize=True. Returns: unmixed: a 4-band image file in order of (burned-veg-npv-soil). \"\"\" endmembers = [ burn , pv , npv ] endmember_names = [ \"burned\" , \"pv\" , \"npv\" ] unmixed = fractionalCover ( img , endmembers , endmember_names , ** normalization ) return unmixed","title":"BVN()"},{"location":"module/Unmix/#earthlib.Unmix.computeModeledSpectra","text":"Constructs a modeled spectrum for each pixel based on endmember fractions. Parameters: Name Type Description Default endmembers a list of _ee.List() items, each representing an endmember spectrum. required fractions ee.Image output from .unmix() with the same number of bands as items in endmembers . required Returns: Type Description modeled_reflectance an _ee.Image with n_bands equal to the number of endmember bands. Source code in earthlib/Unmix.py def computeModeledSpectra ( endmembers , fractions ): \"\"\"Constructs a modeled spectrum for each pixel based on endmember fractions. Args: endmembers: a list of _ee.List() items, each representing an endmember spectrum. fractions: ee.Image output from .unmix() with the same number of bands as items in `endmembers`. Returns: modeled_reflectance: an _ee.Image with n_bands equal to the number of endmember bands. \"\"\" # compute the number of endmember bands nb = int ( endmembers [ 0 ] . length () . getInfo ()) band_range = list ( range ( nb )) band_names = [ f \"M { band : 02d } \" for band in band_range ] # create a list to store each reflectance fraction refl_fraction_images = list () # loop through each endmember and mulitply the fraction estimated by the reflectance value for i , endmember in enumerate ( endmembers ): fraction = fractions . select ([ i ]) refl_fraction_list = [ fraction . multiply ( _ee . Image ( endmember . get ( band ) . getInfo ())) for band in band_range ] refl_fraction_images . append ( _ee . ImageCollection . fromImages ( refl_fraction_list ) . toBands () . select ( band_range , band_names ) ) # convert these images to an image collection and sum them together to reconstruct the spectrum modeled_reflectance = ( _ee . ImageCollection . fromImages ( refl_fraction_images ) . sum () . toFloat () . select ( band_range , band_names ) ) return modeled_reflectance","title":"computeModeledSpectra()"},{"location":"module/Unmix/#earthlib.Unmix.computeSpectralRMSE","text":"Computes root mean squared error between measured and modeled spectra. Parameters: Name Type Description Default measured an ee.Image of measured reflectance. required modeled an ee.Image of modeled reflectance. required Returns: Type Description rmse a floating point _ee.Image with pixel-wise RMSE values. Source code in earthlib/Unmix.py def computeSpectralRMSE ( measured , modeled ): \"\"\"Computes root mean squared error between measured and modeled spectra. Args: measured: an ee.Image of measured reflectance. modeled: an ee.Image of modeled reflectance. Returns: rmse: a floating point _ee.Image with pixel-wise RMSE values. \"\"\" # harmonize band info to ensure element-wise computation band_names = list ( measured . bandNames () . getInfo ()) band_range = list ( range ( len ( band_names ))) # compute rmse rmse = ( measured . select ( band_range , band_names ) . subtract ( modeled . select ( band_range , band_names )) . pow ( 2 ) . reduce ( _ee . Reducer . sum ()) . sqrt () . select ([ 0 ], [ \"RMSE\" ]) . toFloat () ) return rmse","title":"computeSpectralRMSE()"},{"location":"module/Unmix/#earthlib.Unmix.computeWeight","text":"Computes the relative weight for an image's RMSE based on the sum of the global RMSE. Parameters: Name Type Description Default fractions a multi-band ee.Image object with an 'RMSE' band. required rmse_sum a single-band ee.Image object with the global RMSE value. required Returns: Type Description unweighted appends the fractions Image with a 'weight' band. Source code in earthlib/Unmix.py def computeWeight ( fractions , rmse_sum ): \"\"\"Computes the relative weight for an image's RMSE based on the sum of the global RMSE. Args: fractions: a multi-band ee.Image object with an 'RMSE' band. rmse_sum: a single-band ee.Image object with the global RMSE value. Returns: unweighted: appends the fractions Image with a 'weight' band. \"\"\" rmse = fractions . select ([ \"RMSE\" ]) ratio = rmse . divide ( rmse_sum ) . toFloat () . select ([ 0 ], [ \"ratio\" ]) weight = _ee . Image ( 1 ) . subtract ( ratio ) . select ([ 0 ], [ \"weight\" ]) unweighted = fractions . addBands ([ weight , ratio ]) return unweighted","title":"computeWeight()"},{"location":"module/Unmix/#earthlib.Unmix.fractionalCover","text":"Computes the percent cover of each endmember spectra. Parameters: Name Type Description Default img the ee.Image to unmix. required endmembers lists of ee.List objects, each element corresponding to a sub. required endmember_names list of names for each endmember. must match the number of lists passed. required shade_normalize flag to apply shade normalization during unmixing. False Returns: Type Description unmixed a 3-band image file in order of (soil-veg-impervious). Source code in earthlib/Unmix.py def fractionalCover ( img , endmembers , endmember_names , shade_normalize = False , ): \"\"\"Computes the percent cover of each endmember spectra. Args: img: the ee.Image to unmix. endmembers: lists of ee.List objects, each element corresponding to a sub. endmember_names: list of names for each endmember. must match the number of lists passed. shade_normalize: flag to apply shade normalization during unmixing. Returns: unmixed: a 3-band image file in order of (soil-veg-impervious). \"\"\" n_bands = len ( list ( img . bandNames () . getInfo ())) n_classes = len ( endmembers ) n_endmembers = len ( endmembers [ 0 ]) band_numbers = list ( range ( n_classes )) shade = _ee . List ([ 0 ] * n_bands ) # create a list of images to append and later convert to an image collection unmixed = list () # loop through each iteration and unmix each for spectra in _tqdm ( list ( zip ( * endmembers )), total = n_endmembers , desc = \"Unmixing\" ): if shade_normalize : spectra += ( shade ,) unmixed_iter = img . unmix ( spectra , True , True ) . toFloat () # run the forward model to evaluate the fractional cover fit modeled_reflectance = computeModeledSpectra ( spectra , unmixed_iter ) rmse = computeSpectralRMSE ( img , modeled_reflectance ) # normalize by the observed shade fraction if shade_normalize : shade_fraction = unmixed_iter . select ([ n_classes ]) . subtract ( 1 ) . abs () unmixed_iter = unmixed_iter . divide ( shade_fraction ) # rename the bands and append an rmse band unmixed . append ( unmixed_iter . select ( band_numbers , endmember_names ) . addBands ( rmse ) ) # use the sum of rmse to weight each estimate rmse_sum = _ee . Image ( _ee . ImageCollection . fromImages ( unmixed ) . select ([ \"RMSE\" ]) . sum () . select ([ 0 ], [ \"SUM\" ]) . toFloat () ) unscaled = [ computeWeight ( fractions , rmse_sum ) for fractions in unmixed ] # use these weights to scale each unmixing estimate weight_sum = _ee . Image ( _ee . ImageCollection . fromImages ( unscaled ) . select ([ \"weight\" ]) . sum () . toFloat () ) scaled = [ weightedAverage ( fractions , weight_sum ) for fractions in unscaled ] # reduce it to a single image and return unmixed = _ee . ImageCollection . fromImages ( scaled ) . sum () . toFloat () return unmixed","title":"fractionalCover()"},{"location":"module/Unmix/#earthlib.Unmix.Initialize","text":"Initializes sensor-specific global variables. Parameters: Name Type Description Default sensor the name of the sensor (from earthlib.listSensors()). required n the number of iterations for unmixing. 30 bands a list of bands to select (from earthlib.getBands(sensor)). None Returns: Type Description None creates a series of global endmember variables. Source code in earthlib/Unmix.py def Initialize ( sensor , n = 30 , bands = None ): \"\"\"Initializes sensor-specific global variables. Args: sensor: the name of the sensor (from earthlib.listSensors()). n: the number of iterations for unmixing. bands: a list of bands to select (from earthlib.getBands(sensor)). Returns: None: creates a series of global endmember variables. \"\"\" # get them as a python array pv_list = _selectSpectra ( \"vegetation\" , sensor , n , bands ) npv_list = _selectSpectra ( \"npv\" , sensor , n , bands ) soil_list = _selectSpectra ( \"bare\" , sensor , n , bands ) burn_list = _selectSpectra ( \"burn\" , sensor , n , bands ) urban_list = _selectSpectra ( \"urban\" , sensor , n , bands ) # create a series of global variables for later global pv global npv global soil global burn global urban # then convert them to ee lists pv = [ _ee . List ( pv_spectra . tolist ()) for pv_spectra in pv_list ] npv = [ _ee . List ( npv_spectra . tolist ()) for npv_spectra in npv_list ] soil = [ _ee . List ( soil_spectra . tolist ()) for soil_spectra in soil_list ] burn = [ _ee . List ( burn_spectra . tolist ()) for burn_spectra in burn_list ] urban = [ _ee . List ( urban_spectra . tolist ()) for urban_spectra in urban_list ]","title":"Initialize()"},{"location":"module/Unmix/#earthlib.Unmix.SVN","text":"Unmixes using Soil-Vegetation-NonphotosyntheticVegetation (SVN) endmembers. Parameters: Name Type Description Default img the ee.Image to unmix. required **normalization keyword arguments to pass to fractionalCover(), like shade_normalize=True. {} Returns: Type Description unmixed a 3-band image file in order of (soil-veg-npv). Source code in earthlib/Unmix.py def SVN ( img , ** normalization ): \"\"\"Unmixes using Soil-Vegetation-NonphotosyntheticVegetation (SVN) endmembers. Args: img: the ee.Image to unmix. **normalization: keyword arguments to pass to fractionalCover(), like shade_normalize=True. Returns: unmixed: a 3-band image file in order of (soil-veg-npv). \"\"\" endmembers = [ soil , pv , npv ] endmember_names = [ \"soil\" , \"pv\" , \"npv\" ] unmixed = fractionalCover ( img , endmembers , endmember_names , ** normalization ) return unmixed","title":"SVN()"},{"location":"module/Unmix/#earthlib.Unmix.VIS","text":"Unmixes according to the Vegetation-Impervious-Soil (VIS) approach. Parameters: Name Type Description Default img the ee.Image to unmix. required **normalization keyword arguments to pass to fractionalCover(), like shade_normalize=True. {} Returns: Type Description unmixed a 3-band image file in order of (soil-veg-impervious). Source code in earthlib/Unmix.py def VIS ( img , ** normalization ): \"\"\"Unmixes according to the Vegetation-Impervious-Soil (VIS) approach. Args: img: the ee.Image to unmix. **normalization: keyword arguments to pass to fractionalCover(), like shade_normalize=True. Returns: unmixed: a 3-band image file in order of (soil-veg-impervious). \"\"\" endmembers = [ soil , pv , urban ] endmember_names = [ \"soil\" , \"pv\" , \"impervious\" ] unmixed = fractionalCover ( img , endmembers , endmember_names , ** normalization ) return unmixed","title":"VIS()"},{"location":"module/Unmix/#earthlib.Unmix.weightedAverage","text":"Computes an RMSE-weighted fractional cover image. Parameters: Name Type Description Default fractions a multi-band ee.Image object with a 'weight' band. required weight_sum a single-band _eeImage object with the global weight sum. required Returns: Type Description weighted scaled fractional cover Image. Source code in earthlib/Unmix.py def weightedAverage ( fractions , weight_sum ): \"\"\"Computes an RMSE-weighted fractional cover image. Args: fractions: a multi-band ee.Image object with a 'weight' band. weight_sum: a single-band _eeImage object with the global weight sum. Returns: weighted: scaled fractional cover Image. \"\"\" # harmonize band info band_names = list ( fractions . bandNames () . getInfo ()) band_names . pop ( band_names . index ( \"weight\" )) band_range = list ( range ( len ( band_names ))) scaler = fractions . select ([ \"weight\" ]) . divide ( weight_sum ) weighted = fractions . select ( band_range , band_names ) . multiply ( scaler ) return weighted","title":"weightedAverage()"},{"location":"module/utils/","text":"Utility functions for working with spectral libraries and earth engine routines. spectralObject \u00b6 __init__ ( self , n_spectra = 1 , n_wl = 2151 , sensor = None , band_unit = None , band_centers = None , band_quantity = 'Wavelength' ) special \u00b6 Custom object to read, store, write, and plot spectral data. Parameters: Name Type Description Default n_spectra the number of spectra included in the library 1 n_wl the number of wavelengths for each spectrum 2151 sensor the sensor name None band_unit the unit of measurement (typically micrometers or nanometers) None band_centers the center wavelength for each band None band_quantity the quantity measured by each band 'Wavelength' Returns: Type Description s a spectral object. Source code in earthlib/utils.py def __init__ ( self , n_spectra = 1 , n_wl = 2151 , sensor = None , band_unit = None , band_centers = None , band_quantity = \"Wavelength\" , ): \"\"\"Custom object to read, store, write, and plot spectral data. Args: n_spectra: the number of spectra included in the library n_wl: the number of wavelengths for each spectrum sensor: the sensor name band_unit: the unit of measurement (typically micrometers or nanometers) band_centers: the center wavelength for each band band_quantity: the quantity measured by each band Returns: s: a spectral object. \"\"\" # set to asd type if no params set to change n_wl if n_wl == 2151 : sensor = \"asd\" # set up pre-defined types if sensor is not None : if sensor . lower () == \"asd\" : n_wl = 2151 band_unit = \"Nanometers\" band_quantity = \"Wavelength\" band_centers = np . arange ( 350 , 2501 ) # return a list same size as number of spectra self . names = [] for i in range ( n_spectra ): self . names . append ( \"Spectrum {} \" . format ( i )) # set up the band definitions try : self . band_unit = band_unit except NameError : self . band_unit = None try : self . band_quantity = band_quantity except NameError : self . band_quantity = None try : self . band_centers = band_centers except NameError : self . band_centers = None # return an np array size of n spectra x n wavelengths self . spectra = np . zeros ([ n_spectra , n_wl ]) bn ( self , inds = None ) \u00b6 Brightness normalizes the spectra. Parameters: Name Type Description Default inds the band indices to use for normalization. None Returns: Type Description none updates the self.spectra array. Source code in earthlib/utils.py def bn ( self , inds = None ): \"\"\"Brightness normalizes the spectra. Args: inds: the band indices to use for normalization. Returns: none: updates the self.spectra array. \"\"\" # check if indices were set and valid. if not, use all bands if inds : if max ( inds ) > self . spectra . shape [ - 1 ]: inds = range ( 0 , self . spectra . shape [ - 1 ]) print ( \"Invalid range set. using all spectra\" ) if min ( inds ) < 0 : inds = range ( 0 , self . spectra . shape [ - 1 ]) print ( \"Invalid range set. using all spectra\" ) else : inds = range ( 0 , self . spectra . shape [ - 1 ]) # perform the bn self . spectra = self . spectra [:, inds ] / np . expand_dims ( np . sqrt (( self . spectra [:, inds ] ** 2 ) . sum ( 1 )), 1 ) # subset band centers to the indices selected, if they exist if self . band_centers . ndim != 0 : self . band_centers = self . band_centers [ inds ] get_shortwave_bands ( self ) \u00b6 Returns indices of the bands that encompass the shortwave range. This refers to the range (350 - 2500 nm). Returns: Type Description overlap an index of bands to subset to the shortwave range. Source code in earthlib/utils.py def get_shortwave_bands ( self ): \"\"\"Returns indices of the bands that encompass the shortwave range. This refers to the range (350 - 2500 nm). Args: None. Returns: overlap: an index of bands to subset to the shortwave range. \"\"\" # set range to return in nanometers shortwave_range = [ 350.0 , 2500.0 ] # normalize if wavelength units are different if self . band_unit . lower () == \"micrometers\" : shortwave_range /= 1000.0 # find overlapping range gt = np . where ( self . band_centers > shortwave_range [ 0 ]) lt = np . where ( self . band_centers < shortwave_range [ 1 ]) overlap = np . intersect1d ( gt [ 0 ], lt [ 0 ]) # return output return overlap plot ( self , inds = None , legend = False ) \u00b6 Plots the spectra using a standard format Parameters: Name Type Description Default inds optional 0-based indices for which spectra to plot None legend add a legend with the spectra names False Returns: Type Description plt the matplotlib pyplot object Source code in earthlib/utils.py def plot ( self , inds = None , legend = False ): \"\"\"Plots the spectra using a standard format Args: inds: optional 0-based indices for which spectra to plot legend: add a legend with the spectra names Returns: plt: the matplotlib pyplot object \"\"\" # set basic parameters plt . xlim (( self . band_centers . min (), self . band_centers . max ())) plt . xlabel ( \"Wavelength ( {} )\" . format ( self . band_unit )) plt . ylabel ( \"Reflectance (%)\" ) # check if indices were set and valid. if not, plot all items if inds is not None : if np . max ( inds ) > len ( self . names ): inds = range ( 0 , len ( self . names )) print ( \"Invalid range set. using all spectra\" ) if np . min ( inds ) < 0 : inds = range ( 0 , len ( self . names )) print ( \"Invalid range set. using all spectra\" ) else : inds = range ( 0 , len ( self . names )) # plot differently if a single index or a list is passed if type ( inds ) is list : for i in inds : plt . plot ( self . band_centers , self . spectra [ i , :], label = self . names [ i ]) else : plt . plot ( self . band_centers , self . spectra [ inds , :], label = self . names [ inds ]) # add the legend with each spectrum's name if legend : plt . legend ( fontsize = \"small\" , framealpha = 0.5 , fancybox = True ) # display the plot plt . tight_layout () plt . show () return plt remove_water_bands ( self , set_nan = False ) \u00b6 Sets reflectance data from water absorption bands to eithr 0 or NaN. Wavelenths in the ranges of (1.35-1.46 um and 1.79-1.96 um) will be masked. Parameters: Name Type Description Default set_nan set the water bands to NaN. False sets values to 0. False Returns: Type Description None updates the self.spectra array Source code in earthlib/utils.py def remove_water_bands ( self , set_nan = False ): \"\"\"Sets reflectance data from water absorption bands to eithr 0 or NaN. Wavelenths in the ranges of (1.35-1.46 um and 1.79-1.96 um) will be masked. Args: set_nan: set the water bands to NaN. False sets values to 0. Returns: None: updates the self.spectra array \"\"\" if set_nan : update_val = np . nan else : update_val = 0 if self . band_unit . lower () == \"micrometers\" : water_bands = [[ 1.35 , 1.46 ], [ 1.79 , 1.96 ]] else : water_bands = [[ 1350.0 , 1460.0 ], [ 1790.0 , 1960.0 ]] # start with nir-swir1 transition gt = np . where ( self . band_centers > water_bands [ 0 ][ 0 ]) lt = np . where ( self . band_centers < water_bands [ 0 ][ 1 ]) nd = np . intersect1d ( gt [ 0 ], lt [ 0 ]) self . spectra [:, nd ] = update_val # then swir1-swir2 transition gt = np . where ( self . band_centers > water_bands [ 1 ][ 0 ]) lt = np . where ( self . band_centers < water_bands [ 1 ][ 1 ]) nd = np . intersect1d ( gt [ 0 ], lt [ 0 ]) self . spectra [:, nd ] = update_val write_sli ( self , path , row_inds = None , spectral_inds = None ) \u00b6 Writes the spectral object to an ENVI spectral library file. Parameters: Name Type Description Default path the output file to write the array to. required inds the row-wise indices of the array to write out. required Returns: Type Description None writes the data to disk. Source code in earthlib/utils.py def write_sli ( self , path , row_inds = None , spectral_inds = None ): \"\"\"Writes the spectral object to an ENVI spectral library file. Args: path: the output file to write the array to. inds: the row-wise indices of the array to write out. Returns: None: writes the data to disk. \"\"\" # set up the output file names for the library and the header base , ext = os . path . splitext ( path ) if ext . lower () == \".sli\" : osli = path ohdr = \" {} .hdr\" . format ( base ) elif ext . lower () == \".hdr\" : osli = \" {} .hdr\" . format ( base ) ohdr = path else : osli = \" {} .sli\" . format ( base ) ohdr = \" {} .hdr\" . format ( base ) # subset the data if specific indices are set spectra = self . spectra names = self . names band_centers = self . band_centers if row_inds is not None : spectra = spectra [ row_inds , :] names = np . array ( names )[ row_inds ] if spectral_inds is not None : spectra = spectra [:, spectral_inds ] band_centers = band_centers [ spectral_inds ] # set up the metadata for the ENVI header file metadata = { \"samples\" : len ( band_centers ), \"lines\" : len ( names ), \"bands\" : 1 , \"data type\" : 4 , \"header offset\" : 0 , \"interleave\" : \"bsq\" , \"byte order\" : 0 , \"sensor type\" : \"earthlib\" , \"spectra names\" : names , \"wavelength units\" : self . band_unit , \"wavelength\" : band_centers , } spectral . envi . write_envi_header ( ohdr , metadata , is_library = True ) # then write the spectral library with open ( osli , \"w\" ) as f : spectra . astype ( np . float32 ) . tofile ( f ) checkFile ( path ) \u00b6 Verifies whether a file exists and can be read. Parameters: Name Type Description Default path the file path to check. required Returns: Type Description boolean. Source code in earthlib/utils.py def checkFile ( path ): \"\"\"Verifies whether a file exists and can be read. Args: path: the file path to check. Returns: boolean. \"\"\" if os . path . isfile ( path ) and os . access ( path , os . R_OK ): return True else : return False getBandIndices ( custom_bands , sensor ) \u00b6 Cross-references a list of bands passed as strings to the 0-based integer indices Parameters: Name Type Description Default custom_bands a list of band names. required sensor a string sensor type for indexing the supported collections. required Returns: Type Description indices list of integer band indices. Source code in earthlib/utils.py def getBandIndices ( custom_bands , sensor ): \"\"\"Cross-references a list of bands passed as strings to the 0-based integer indices Args: custom_bands: a list of band names. sensor: a string sensor type for indexing the supported collections. Returns: indices: list of integer band indices. \"\"\" sensor_bands = collections [ sensor ][ \"band_names\" ] indices = list () for band in custom_bands : if band in sensor_bands : indices . append ( sensor_bands . index ( band )) indices . sort () return indices getBands ( sensor ) \u00b6 Returns a list of available band names by sensor. Parameters: Name Type Description Default sensor the name of the sensor (from earthlib.listSensors()). required Returns: Type Description bands a list of sensor-specific band names. Source code in earthlib/utils.py def getBands ( sensor ): \"\"\"Returns a list of available band names by sensor. Args: sensor: the name of the sensor (from earthlib.listSensors()). Returns: bands: a list of sensor-specific band names. \"\"\" bands = collections [ sensor ][ \"band_names\" ] return bands getCollection ( sensor ) \u00b6 Returns the earth engine collection name for a specific satellite sensor. Parameters: Name Type Description Default sensor the name of the sensor (from earthlib.listSensors()). required Returns: Type Description collection a string with the earth engine collection. Source code in earthlib/utils.py def getCollection ( sensor ): \"\"\"Returns the earth engine collection name for a specific satellite sensor. Args: sensor: the name of the sensor (from earthlib.listSensors()). Returns: collection: a string with the earth engine collection. \"\"\" collection = collections [ sensor ][ \"collection\" ] return collection getScaler ( sensor ) \u00b6 Returns the scaling factor to convert sensor data to percent reflectance (0-1). Parameters: Name Type Description Default sensor the name of the sensor (from earthlib.listSensors()). required Returns: Type Description scaler the scale factor to multiply. Source code in earthlib/utils.py def getScaler ( sensor ): \"\"\"Returns the scaling factor to convert sensor data to percent reflectance (0-1). Args: sensor: the name of the sensor (from earthlib.listSensors()). Returns: scaler: the scale factor to multiply. \"\"\" scaler = collections [ sensor ][ \"scale\" ] return scaler getTypeLevel ( Type ) \u00b6 Checks whether a spectral data type is available in the endmember library. Parameters: Name Type Description Default Type the type of spectra to select. required Returns: Type Description level the metadata \"level\" of the group for subsetting. returns 0 if not found. Source code in earthlib/utils.py def getTypeLevel ( Type ): \"\"\"Checks whether a spectral data type is available in the endmember library. Args: Type: the type of spectra to select. Returns: level: the metadata \"level\" of the group for subsetting. returns 0 if not found. \"\"\" for i in range ( 4 ): level = i + 1 available_types = listTypes ( level = level ) if Type in available_types : return level return 0 listSensors () \u00b6 Returns a list of the supported sensor image collections. Returns: Type Description sensors a list of supported sensors using the names referenced by this package. Source code in earthlib/utils.py def listSensors (): \"\"\"Returns a list of the supported sensor image collections. Args: None Returns: sensors: a list of supported sensors using the names referenced by this package. \"\"\" sensors = list ( collections . keys ()) return sensors listTypes ( level = 2 ) \u00b6 Returns a list of the spectral classification types. Parameters: Name Type Description Default level the level of spectral classification specificity to return. Supports integers 1-4. 2 Returns: Type Description classes a list of spectral data types referenced throughout this package. Source code in earthlib/utils.py def listTypes ( level = 2 ): \"\"\"Returns a list of the spectral classification types. Args: level: the level of spectral classification specificity to return. Supports integers 1-4. Returns: classes: a list of spectral data types referenced throughout this package. \"\"\" key = f \"LEVEL_ { level } \" types = list ( metadata [ key ] . unique ()) return types selectSpectra ( Type , sensor , n = 0 , bands = None ) \u00b6 Subsets the earthlib spectral endmember library. Selects endmembers from specific class, then resamples the spectra to the wavelengths of a specific satellite sensor. This also performs random spectra selection. Parameters: Name Type Description Default Type the type of spectra to select. required sensor the sensor type to resample wavelengths to. required n the number of random spectra to sample. n=0 returns all spectra. 0 bands list of bands to use. Accepts 0-based indices or a list of band names (e.g. [\"B2\", \"B3\", \"B4\"]). None Returns: Type Description spectra list of spectral endmembers resampled to a specific sensor's wavelengths. Source code in earthlib/utils.py def selectSpectra ( Type , sensor , n = 0 , bands = None ): \"\"\"Subsets the earthlib spectral endmember library. Selects endmembers from specific class, then resamples the spectra to the wavelengths of a specific satellite sensor. This also performs random spectra selection. Args: Type: the type of spectra to select. sensor: the sensor type to resample wavelengths to. n: the number of random spectra to sample. n=0 returns all spectra. bands: list of bands to use. Accepts 0-based indices or a list of band names (e.g. [\"B2\", \"B3\", \"B4\"]). Returns: spectra: list of spectral endmembers resampled to a specific sensor's wavelengths. \"\"\" import spectral from . import Read # get the level of the group selected level = getTypeLevel ( Type ) if level == 0 : LOGGER . warning ( f \"Invalid group parameter: { Type } . Get valid values from earthlib.listTypes().\" ) return None # qc the collection selected if sensor not in listSensors (): LOGGER . warning ( f \"Invalid sensor parameter: { sensor } . Get valid values from earthlib.listSensors().\" ) return None # read the spectral library into memory endmembers = Read . spectralLibrary ( _endmember_path ) # subset to specific bands, if set if bands is None : bands = range ( len ( getBands ( sensor ))) else : if type ( bands [ 0 ]) is str : bands = getBandIndices ( bands , sensor ) # create a band resampler for this collection sensor_centers = np . array ( collections [ sensor ][ \"band_centers\" ])[ bands ] sensor_fwhm = np . array ( collections [ sensor ][ \"band_widths\" ])[ bands ] resampler = spectral . BandResampler ( endmembers . band_centers , sensor_centers , fwhm2 = sensor_fwhm ) # select the endmembers from just the type passed key = f \"LEVEL_ { level } \" indices = metadata [ key ] == Type spectra_raw = endmembers . spectra [ indices , :] # subset them further if the n parameter is passed if n > 0 : random_indices = np . random . randint ( indices . sum (), size = n ) spectra_raw = spectra_raw [ random_indices , :] # loop through each spectrum and resample to the sensor wavelengths resampled = list () for i in range ( spectra_raw . shape [ 0 ]): spectrum = resampler ( spectra_raw [ i , :]) resampled . append ( spectrum ) return resampled","title":"earthlib.utils"},{"location":"module/utils/#earthlib.utils.spectralObject","text":"","title":"spectralObject"},{"location":"module/utils/#earthlib.utils.spectralObject.__init__","text":"Custom object to read, store, write, and plot spectral data. Parameters: Name Type Description Default n_spectra the number of spectra included in the library 1 n_wl the number of wavelengths for each spectrum 2151 sensor the sensor name None band_unit the unit of measurement (typically micrometers or nanometers) None band_centers the center wavelength for each band None band_quantity the quantity measured by each band 'Wavelength' Returns: Type Description s a spectral object. Source code in earthlib/utils.py def __init__ ( self , n_spectra = 1 , n_wl = 2151 , sensor = None , band_unit = None , band_centers = None , band_quantity = \"Wavelength\" , ): \"\"\"Custom object to read, store, write, and plot spectral data. Args: n_spectra: the number of spectra included in the library n_wl: the number of wavelengths for each spectrum sensor: the sensor name band_unit: the unit of measurement (typically micrometers or nanometers) band_centers: the center wavelength for each band band_quantity: the quantity measured by each band Returns: s: a spectral object. \"\"\" # set to asd type if no params set to change n_wl if n_wl == 2151 : sensor = \"asd\" # set up pre-defined types if sensor is not None : if sensor . lower () == \"asd\" : n_wl = 2151 band_unit = \"Nanometers\" band_quantity = \"Wavelength\" band_centers = np . arange ( 350 , 2501 ) # return a list same size as number of spectra self . names = [] for i in range ( n_spectra ): self . names . append ( \"Spectrum {} \" . format ( i )) # set up the band definitions try : self . band_unit = band_unit except NameError : self . band_unit = None try : self . band_quantity = band_quantity except NameError : self . band_quantity = None try : self . band_centers = band_centers except NameError : self . band_centers = None # return an np array size of n spectra x n wavelengths self . spectra = np . zeros ([ n_spectra , n_wl ])","title":"__init__()"},{"location":"module/utils/#earthlib.utils.spectralObject.bn","text":"Brightness normalizes the spectra. Parameters: Name Type Description Default inds the band indices to use for normalization. None Returns: Type Description none updates the self.spectra array. Source code in earthlib/utils.py def bn ( self , inds = None ): \"\"\"Brightness normalizes the spectra. Args: inds: the band indices to use for normalization. Returns: none: updates the self.spectra array. \"\"\" # check if indices were set and valid. if not, use all bands if inds : if max ( inds ) > self . spectra . shape [ - 1 ]: inds = range ( 0 , self . spectra . shape [ - 1 ]) print ( \"Invalid range set. using all spectra\" ) if min ( inds ) < 0 : inds = range ( 0 , self . spectra . shape [ - 1 ]) print ( \"Invalid range set. using all spectra\" ) else : inds = range ( 0 , self . spectra . shape [ - 1 ]) # perform the bn self . spectra = self . spectra [:, inds ] / np . expand_dims ( np . sqrt (( self . spectra [:, inds ] ** 2 ) . sum ( 1 )), 1 ) # subset band centers to the indices selected, if they exist if self . band_centers . ndim != 0 : self . band_centers = self . band_centers [ inds ]","title":"bn()"},{"location":"module/utils/#earthlib.utils.spectralObject.get_shortwave_bands","text":"Returns indices of the bands that encompass the shortwave range. This refers to the range (350 - 2500 nm). Returns: Type Description overlap an index of bands to subset to the shortwave range. Source code in earthlib/utils.py def get_shortwave_bands ( self ): \"\"\"Returns indices of the bands that encompass the shortwave range. This refers to the range (350 - 2500 nm). Args: None. Returns: overlap: an index of bands to subset to the shortwave range. \"\"\" # set range to return in nanometers shortwave_range = [ 350.0 , 2500.0 ] # normalize if wavelength units are different if self . band_unit . lower () == \"micrometers\" : shortwave_range /= 1000.0 # find overlapping range gt = np . where ( self . band_centers > shortwave_range [ 0 ]) lt = np . where ( self . band_centers < shortwave_range [ 1 ]) overlap = np . intersect1d ( gt [ 0 ], lt [ 0 ]) # return output return overlap","title":"get_shortwave_bands()"},{"location":"module/utils/#earthlib.utils.spectralObject.plot","text":"Plots the spectra using a standard format Parameters: Name Type Description Default inds optional 0-based indices for which spectra to plot None legend add a legend with the spectra names False Returns: Type Description plt the matplotlib pyplot object Source code in earthlib/utils.py def plot ( self , inds = None , legend = False ): \"\"\"Plots the spectra using a standard format Args: inds: optional 0-based indices for which spectra to plot legend: add a legend with the spectra names Returns: plt: the matplotlib pyplot object \"\"\" # set basic parameters plt . xlim (( self . band_centers . min (), self . band_centers . max ())) plt . xlabel ( \"Wavelength ( {} )\" . format ( self . band_unit )) plt . ylabel ( \"Reflectance (%)\" ) # check if indices were set and valid. if not, plot all items if inds is not None : if np . max ( inds ) > len ( self . names ): inds = range ( 0 , len ( self . names )) print ( \"Invalid range set. using all spectra\" ) if np . min ( inds ) < 0 : inds = range ( 0 , len ( self . names )) print ( \"Invalid range set. using all spectra\" ) else : inds = range ( 0 , len ( self . names )) # plot differently if a single index or a list is passed if type ( inds ) is list : for i in inds : plt . plot ( self . band_centers , self . spectra [ i , :], label = self . names [ i ]) else : plt . plot ( self . band_centers , self . spectra [ inds , :], label = self . names [ inds ]) # add the legend with each spectrum's name if legend : plt . legend ( fontsize = \"small\" , framealpha = 0.5 , fancybox = True ) # display the plot plt . tight_layout () plt . show () return plt","title":"plot()"},{"location":"module/utils/#earthlib.utils.spectralObject.remove_water_bands","text":"Sets reflectance data from water absorption bands to eithr 0 or NaN. Wavelenths in the ranges of (1.35-1.46 um and 1.79-1.96 um) will be masked. Parameters: Name Type Description Default set_nan set the water bands to NaN. False sets values to 0. False Returns: Type Description None updates the self.spectra array Source code in earthlib/utils.py def remove_water_bands ( self , set_nan = False ): \"\"\"Sets reflectance data from water absorption bands to eithr 0 or NaN. Wavelenths in the ranges of (1.35-1.46 um and 1.79-1.96 um) will be masked. Args: set_nan: set the water bands to NaN. False sets values to 0. Returns: None: updates the self.spectra array \"\"\" if set_nan : update_val = np . nan else : update_val = 0 if self . band_unit . lower () == \"micrometers\" : water_bands = [[ 1.35 , 1.46 ], [ 1.79 , 1.96 ]] else : water_bands = [[ 1350.0 , 1460.0 ], [ 1790.0 , 1960.0 ]] # start with nir-swir1 transition gt = np . where ( self . band_centers > water_bands [ 0 ][ 0 ]) lt = np . where ( self . band_centers < water_bands [ 0 ][ 1 ]) nd = np . intersect1d ( gt [ 0 ], lt [ 0 ]) self . spectra [:, nd ] = update_val # then swir1-swir2 transition gt = np . where ( self . band_centers > water_bands [ 1 ][ 0 ]) lt = np . where ( self . band_centers < water_bands [ 1 ][ 1 ]) nd = np . intersect1d ( gt [ 0 ], lt [ 0 ]) self . spectra [:, nd ] = update_val","title":"remove_water_bands()"},{"location":"module/utils/#earthlib.utils.spectralObject.write_sli","text":"Writes the spectral object to an ENVI spectral library file. Parameters: Name Type Description Default path the output file to write the array to. required inds the row-wise indices of the array to write out. required Returns: Type Description None writes the data to disk. Source code in earthlib/utils.py def write_sli ( self , path , row_inds = None , spectral_inds = None ): \"\"\"Writes the spectral object to an ENVI spectral library file. Args: path: the output file to write the array to. inds: the row-wise indices of the array to write out. Returns: None: writes the data to disk. \"\"\" # set up the output file names for the library and the header base , ext = os . path . splitext ( path ) if ext . lower () == \".sli\" : osli = path ohdr = \" {} .hdr\" . format ( base ) elif ext . lower () == \".hdr\" : osli = \" {} .hdr\" . format ( base ) ohdr = path else : osli = \" {} .sli\" . format ( base ) ohdr = \" {} .hdr\" . format ( base ) # subset the data if specific indices are set spectra = self . spectra names = self . names band_centers = self . band_centers if row_inds is not None : spectra = spectra [ row_inds , :] names = np . array ( names )[ row_inds ] if spectral_inds is not None : spectra = spectra [:, spectral_inds ] band_centers = band_centers [ spectral_inds ] # set up the metadata for the ENVI header file metadata = { \"samples\" : len ( band_centers ), \"lines\" : len ( names ), \"bands\" : 1 , \"data type\" : 4 , \"header offset\" : 0 , \"interleave\" : \"bsq\" , \"byte order\" : 0 , \"sensor type\" : \"earthlib\" , \"spectra names\" : names , \"wavelength units\" : self . band_unit , \"wavelength\" : band_centers , } spectral . envi . write_envi_header ( ohdr , metadata , is_library = True ) # then write the spectral library with open ( osli , \"w\" ) as f : spectra . astype ( np . float32 ) . tofile ( f )","title":"write_sli()"},{"location":"module/utils/#earthlib.utils.checkFile","text":"Verifies whether a file exists and can be read. Parameters: Name Type Description Default path the file path to check. required Returns: Type Description boolean. Source code in earthlib/utils.py def checkFile ( path ): \"\"\"Verifies whether a file exists and can be read. Args: path: the file path to check. Returns: boolean. \"\"\" if os . path . isfile ( path ) and os . access ( path , os . R_OK ): return True else : return False","title":"checkFile()"},{"location":"module/utils/#earthlib.utils.getBandIndices","text":"Cross-references a list of bands passed as strings to the 0-based integer indices Parameters: Name Type Description Default custom_bands a list of band names. required sensor a string sensor type for indexing the supported collections. required Returns: Type Description indices list of integer band indices. Source code in earthlib/utils.py def getBandIndices ( custom_bands , sensor ): \"\"\"Cross-references a list of bands passed as strings to the 0-based integer indices Args: custom_bands: a list of band names. sensor: a string sensor type for indexing the supported collections. Returns: indices: list of integer band indices. \"\"\" sensor_bands = collections [ sensor ][ \"band_names\" ] indices = list () for band in custom_bands : if band in sensor_bands : indices . append ( sensor_bands . index ( band )) indices . sort () return indices","title":"getBandIndices()"},{"location":"module/utils/#earthlib.utils.getBands","text":"Returns a list of available band names by sensor. Parameters: Name Type Description Default sensor the name of the sensor (from earthlib.listSensors()). required Returns: Type Description bands a list of sensor-specific band names. Source code in earthlib/utils.py def getBands ( sensor ): \"\"\"Returns a list of available band names by sensor. Args: sensor: the name of the sensor (from earthlib.listSensors()). Returns: bands: a list of sensor-specific band names. \"\"\" bands = collections [ sensor ][ \"band_names\" ] return bands","title":"getBands()"},{"location":"module/utils/#earthlib.utils.getCollection","text":"Returns the earth engine collection name for a specific satellite sensor. Parameters: Name Type Description Default sensor the name of the sensor (from earthlib.listSensors()). required Returns: Type Description collection a string with the earth engine collection. Source code in earthlib/utils.py def getCollection ( sensor ): \"\"\"Returns the earth engine collection name for a specific satellite sensor. Args: sensor: the name of the sensor (from earthlib.listSensors()). Returns: collection: a string with the earth engine collection. \"\"\" collection = collections [ sensor ][ \"collection\" ] return collection","title":"getCollection()"},{"location":"module/utils/#earthlib.utils.getScaler","text":"Returns the scaling factor to convert sensor data to percent reflectance (0-1). Parameters: Name Type Description Default sensor the name of the sensor (from earthlib.listSensors()). required Returns: Type Description scaler the scale factor to multiply. Source code in earthlib/utils.py def getScaler ( sensor ): \"\"\"Returns the scaling factor to convert sensor data to percent reflectance (0-1). Args: sensor: the name of the sensor (from earthlib.listSensors()). Returns: scaler: the scale factor to multiply. \"\"\" scaler = collections [ sensor ][ \"scale\" ] return scaler","title":"getScaler()"},{"location":"module/utils/#earthlib.utils.getTypeLevel","text":"Checks whether a spectral data type is available in the endmember library. Parameters: Name Type Description Default Type the type of spectra to select. required Returns: Type Description level the metadata \"level\" of the group for subsetting. returns 0 if not found. Source code in earthlib/utils.py def getTypeLevel ( Type ): \"\"\"Checks whether a spectral data type is available in the endmember library. Args: Type: the type of spectra to select. Returns: level: the metadata \"level\" of the group for subsetting. returns 0 if not found. \"\"\" for i in range ( 4 ): level = i + 1 available_types = listTypes ( level = level ) if Type in available_types : return level return 0","title":"getTypeLevel()"},{"location":"module/utils/#earthlib.utils.listSensors","text":"Returns a list of the supported sensor image collections. Returns: Type Description sensors a list of supported sensors using the names referenced by this package. Source code in earthlib/utils.py def listSensors (): \"\"\"Returns a list of the supported sensor image collections. Args: None Returns: sensors: a list of supported sensors using the names referenced by this package. \"\"\" sensors = list ( collections . keys ()) return sensors","title":"listSensors()"},{"location":"module/utils/#earthlib.utils.listTypes","text":"Returns a list of the spectral classification types. Parameters: Name Type Description Default level the level of spectral classification specificity to return. Supports integers 1-4. 2 Returns: Type Description classes a list of spectral data types referenced throughout this package. Source code in earthlib/utils.py def listTypes ( level = 2 ): \"\"\"Returns a list of the spectral classification types. Args: level: the level of spectral classification specificity to return. Supports integers 1-4. Returns: classes: a list of spectral data types referenced throughout this package. \"\"\" key = f \"LEVEL_ { level } \" types = list ( metadata [ key ] . unique ()) return types","title":"listTypes()"},{"location":"module/utils/#earthlib.utils.selectSpectra","text":"Subsets the earthlib spectral endmember library. Selects endmembers from specific class, then resamples the spectra to the wavelengths of a specific satellite sensor. This also performs random spectra selection. Parameters: Name Type Description Default Type the type of spectra to select. required sensor the sensor type to resample wavelengths to. required n the number of random spectra to sample. n=0 returns all spectra. 0 bands list of bands to use. Accepts 0-based indices or a list of band names (e.g. [\"B2\", \"B3\", \"B4\"]). None Returns: Type Description spectra list of spectral endmembers resampled to a specific sensor's wavelengths. Source code in earthlib/utils.py def selectSpectra ( Type , sensor , n = 0 , bands = None ): \"\"\"Subsets the earthlib spectral endmember library. Selects endmembers from specific class, then resamples the spectra to the wavelengths of a specific satellite sensor. This also performs random spectra selection. Args: Type: the type of spectra to select. sensor: the sensor type to resample wavelengths to. n: the number of random spectra to sample. n=0 returns all spectra. bands: list of bands to use. Accepts 0-based indices or a list of band names (e.g. [\"B2\", \"B3\", \"B4\"]). Returns: spectra: list of spectral endmembers resampled to a specific sensor's wavelengths. \"\"\" import spectral from . import Read # get the level of the group selected level = getTypeLevel ( Type ) if level == 0 : LOGGER . warning ( f \"Invalid group parameter: { Type } . Get valid values from earthlib.listTypes().\" ) return None # qc the collection selected if sensor not in listSensors (): LOGGER . warning ( f \"Invalid sensor parameter: { sensor } . Get valid values from earthlib.listSensors().\" ) return None # read the spectral library into memory endmembers = Read . spectralLibrary ( _endmember_path ) # subset to specific bands, if set if bands is None : bands = range ( len ( getBands ( sensor ))) else : if type ( bands [ 0 ]) is str : bands = getBandIndices ( bands , sensor ) # create a band resampler for this collection sensor_centers = np . array ( collections [ sensor ][ \"band_centers\" ])[ bands ] sensor_fwhm = np . array ( collections [ sensor ][ \"band_widths\" ])[ bands ] resampler = spectral . BandResampler ( endmembers . band_centers , sensor_centers , fwhm2 = sensor_fwhm ) # select the endmembers from just the type passed key = f \"LEVEL_ { level } \" indices = metadata [ key ] == Type spectra_raw = endmembers . spectra [ indices , :] # subset them further if the n parameter is passed if n > 0 : random_indices = np . random . randint ( indices . sum (), size = n ) spectra_raw = spectra_raw [ random_indices , :] # loop through each spectrum and resample to the sensor wavelengths resampled = list () for i in range ( spectra_raw . shape [ 0 ]): spectrum = resampler ( spectra_raw [ i , :]) resampled . append ( spectrum ) return resampled","title":"selectSpectra()"}]}